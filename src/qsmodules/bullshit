enum QSStructures {
    Monad,
    Dyad,
    Triad,
    Tetrad,
    Pentad,
    Hexad,
    Heptad,
    Octad,
    Nonad,
    Decad,
    Undecad,
    Dodecad,
}

struct Monad {
    name: String,
}

struct Triad {
    name: String,
    active: String,
    reconciling: String,
    passive: String,
}

struct Tetrad {
    name: String,
    ideal: String,
    ground: String,
    directive: String,
    instrumental: String,
}

struct Pentad {
    name: String,
    intrinsiclimit: String,
    innerupperlimit: String,
    innerlowerlimit: String,
    outerupperlimit: String,
    outerlowerlimit: String,
}

let cetetradiccriterea = Tetrad {
    name: "CE Tetrad".to_string(),
    ideal: "Origination Myth".to_string(),
    ground: "Existential Foundation".to_string(),
    directive: "Law Comformable".to_string(),
    instrumental: "Rich Structure".to_string(),
};

impl Dyad {
    fn new(name: &str, essence: &str, existence: &str,) -> Self {
        Self {
            name: name.to_string(),
            essence: essence.to_string(),
            existence: existence.to_string(),
        }
    }
    fn print(&self) { // function to print the terms
        for essence in &self.dyad {
            // & because Vec<City> isn't Copy
            println!("{:?} has a population of {:?}.", city.name, city.population);
        }
}









#[derive(Debug)]

struct Dyad {
    name: String,
    essence: String,
    existence: String,
}


fn main() {
    let yinyang = Dyad {
        name: "yinyang".to_string(),
        essence: "yin".to_string(),
        existence: "yang".to_string()
    };

    println!("Yin Yang is a {:?}", yinyang);
}


fn main() {
    let cetetrad = Tetrad {
        name: "CE Tetrad".to_string(),
        ground: "Existential Foundation".to_string(),
        ideal: "Origination Myth".to_string(),
        instrumental: "Rich Narrative Structure".to_string(),
        directive: "Law Conformity".to_string(),
    };